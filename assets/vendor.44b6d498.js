var p=function(){function n(t,e){for(var r=0;r<e.length;r++){var a=e[r];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}}return function(t,e,r){return e&&n(t.prototype,e),r&&n(t,r),t}}();function c(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}var f=function(){function n(t,e){c(this,n),this._reset(),this.fileContents=t,this.defaultModelName=e||"untitled"}return p(n,[{key:"_reset",value:function(){this.result={models:[],materialLibraries:[]},this.currentMaterial="",this.currentGroup="",this.smoothingGroup=0}},{key:"parse",value:function(){this._reset();for(var e=function(u){var i=u.indexOf("#");return i>-1?u.substring(0,i):u},r=this.fileContents.split(`
`),a=0;a<r.length;a+=1){var o=e(r[a]),s=o.replace(/\s\s+/g," ").trim().split(" ");switch(s[0].toLowerCase()){case"o":this._parseObject(s);break;case"g":this._parseGroup(s);break;case"v":this._parseVertexCoords(s);break;case"vt":this._parseTextureCoords(s);break;case"vn":this._parseVertexNormal(s);break;case"s":this._parseSmoothShadingStatement(s);break;case"f":this._parsePolygon(s);break;case"mtllib":this._parseMtlLib(s);break;case"usemtl":this._parseUseMtl(s);break}}return this.result}},{key:"_currentModel",value:function(){return this.result.models.length==0&&(this.result.models.push({name:this.defaultModelName,vertices:[],textureCoords:[],vertexNormals:[],faces:[]}),this.currentGroup="",this.smoothingGroup=0),this.result.models[this.result.models.length-1]}},{key:"_parseObject",value:function(e){var r=e.length>=2?e[1]:this.defaultModelName;this.result.models.push({name:r,vertices:[],textureCoords:[],vertexNormals:[],faces:[]}),this.currentGroup="",this.smoothingGroup=0}},{key:"_parseGroup",value:function(e){if(e.length!=2)throw"Group statements must have exactly 1 argument (eg. g group_1)";this.currentGroup=e[1]}},{key:"_parseVertexCoords",value:function(e){var r=e.length>=2?parseFloat(e[1]):0,a=e.length>=3?parseFloat(e[2]):0,o=e.length>=4?parseFloat(e[3]):0;this._currentModel().vertices.push({x:r,y:a,z:o})}},{key:"_parseTextureCoords",value:function(e){var r=e.length>=2?parseFloat(e[1]):0,a=e.length>=3?parseFloat(e[2]):0,o=e.length>=4?parseFloat(e[3]):0;this._currentModel().textureCoords.push({u:r,v:a,w:o})}},{key:"_parseVertexNormal",value:function(e){var r=e.length>=2?parseFloat(e[1]):0,a=e.length>=3?parseFloat(e[2]):0,o=e.length>=4?parseFloat(e[3]):0;this._currentModel().vertexNormals.push({x:r,y:a,z:o})}},{key:"_parsePolygon",value:function(e){var r=e.length-1;if(r<3)throw"Face statement has less than 3 vertices"+this.filePath+this.lineNumber;for(var a={material:this.currentMaterial,group:this.currentGroup,smoothingGroup:this.smoothingGroup,vertices:[]},o=0;o<r;o+=1){var s=e[o+1],h=s.split("/");if(h.length<1||h.length>3)throw"Two many values (separated by /) for a single vertex"+this.filePath+this.lineNumber;var u=0,i=0,l=0;if(u=parseInt(h[0]),h.length>1&&!h[1]==""&&(i=parseInt(h[1])),h.length>2&&(l=parseInt(h[2])),u==0)throw"Faces uses invalid vertex index of 0";u<0&&(u=this._currentModel().vertices.length+1+u),a.vertices.push({vertexIndex:u,textureCoordsIndex:i,vertexNormalIndex:l})}this._currentModel().faces.push(a)}},{key:"_parseMtlLib",value:function(e){e.length>=2&&this.result.materialLibraries.push(e[1])}},{key:"_parseUseMtl",value:function(e){e.length>=2&&(this.currentMaterial=e[1])}},{key:"_parseSmoothShadingStatement",value:function(e){if(e.length!=2)throw"Smoothing group statements must have exactly 1 argument (eg. s <number|off>)";var r=e[1].toLowerCase()=="off"?0:parseInt(e[1]);this.smoothingGroup=r}}]),n}(),v=f;export{v as O};
